"""
SZZ module: Helps to find where a bug is introduced
"""

import os
import json
from datetime import datetime
import git
import whatthepatch
import pandas as pd
from vulnerability_prediction import OUTPUT_DIR, REPOS

SZZ_LOG_PATH = os.path.join(OUTPUT_DIR, "szz_log.json")


def get_szz_log():
    """Returns a dictionary of szz_log"""
    szz_log = {}
    try:
        with open(SZZ_LOG_PATH, "r") as f_stream:
            szz_log = json.load(f_stream)
    except FileNotFoundError as exc:
        print(exc)

    return szz_log


def find_bug_inducing_commits(repo, bug_commit_df, output_path):
    """
    Iterates over bug - commit matching and finds where a bug
    is introduced by comparing commit diffs.
    Exports a CSV file of (inducing_commit, file, fixing_commit) tuples.
    :param repo: git.Repo
        the repo object
    :param bug_commit_df: pd.DataFrame
        DataFrame of bug-commit matching
    :output_path: string
        Output path to export bug inducing file changes CSV
    """
    commits = list(repo.iter_commits())
    inducing_pairs = []

    total = len(bug_commit_df)

    for idx, row in bug_commit_df.iterrows():
        commit_id = row["commit_id"]
        commit = [c for c in commits if c.hexsha == commit_id]
        if len(commit) > 0:
            commit = commit[0]
        else:
            continue

        header = "[{}/{}]".format(idx, total)

        logs = get_diff_logs(repo, commit_id)
        print("{} {} log entry for commit: {}".format(
            header, len(logs), commit_id))

        for log_entry in logs:
            print("{} File name: {}".format(header, log_entry["file"]))

            inducing_commit = process_lines(
                repo, commit_id, log_entry["lines"],
                log_entry["file"], str(commit.committed_datetime.date())
            )

            if inducing_commit is not None:
                print("\n{} ind_commit: {} File: {} fix commit: {}\n".format(
                    header, inducing_commit, log_entry["file"], commit_id))

                inducing_pairs.append(
                    (inducing_commit, log_entry["file"], commit_id))

                bug_inducing_df = pd.DataFrame(inducing_pairs, columns=[
                    "inducing_id", "file", "fixing_id"]).drop_duplicates()
                bug_inducing_df.to_csv(output_path, index=False)

    return inducing_pairs


def process_lines(repo, fixing_commit, lines, file_name, date):
    """
    Iterates over source code lines and applies git log command
    to find in which commit this line is added to the code.
    :param repo: git.Repo
        the repo object
    :param fixing_commit: string
        hexsha of fixing commit
    :param lines: list[string]
        List of source code lines obtained by git diff
    :param file_name: string
        name of the file
    :param date: string
        Date of commit
    :returns: string
        Hexsha of inducing commit
    """
    for line in lines:
        call = "--format=%H --until={} -S '{}' {}".format(
            date, line, file_name)
        print("Call:" + call)

        # pylint: disable = broad-except
        try:
            log = repo.git.log('--format=%H', "--until={}".format(date), '-S',
                               line, file_name)
        except Exception as ex:
            print("Error in Line:  " + line, ex)
            log = ""
        # pylint: enable = broad-except

        log_lines = log.split('\n')
        print("Commit Amount: {}".format(len(log_lines)))
        for commit_sha in log_lines:
            if not commit_sha or commit_sha == '':
                continue
            if commit_sha != fixing_commit:
                return commit_sha

        return None


def get_diff_logs(repo, commit_sha):
    """
    Parses the diff and obtains the source code lines of given commit.
    :param repo: git.Repo
        the repo object
    :param commit_sha: string
        hexsha of commit
    :returns: list[{file: string, lines: list[string]}]
        List of diff info
    """
    diff_result = repo.git.diff(commit_sha + '~', commit_sha)
    logs = []
    for difference in whatthepatch.parse_patch(diff_result):
        diff = {}

        if difference.header.old_path != ".gitignore":
            diff["file"] = difference.header.old_path

            lines = []
            if difference.changes is None:
                return logs
            for change in difference.changes:
                if change[1] is None:
                    lines.append(change[2])
            diff["lines"] = lines
            logs.append(diff)

    return logs


def main():
    """
    Parses the diff and obtains the source code lines of given commit.
    :param repo: git.Repo
        the repo object
    :param commit_sha: string
        hexsha of commit
    :returns: list[{file: string, lines: list[string]}]
        List of diff info
    """
    szz_log = get_szz_log()
    for repo_entry in REPOS.items():
        repo_key, repo_def = repo_entry
        repo = git.Repo(repo_def["path"])

        if repo_key in szz_log and szz_log["name"]["finished"]:
            print("{} is already analyzed with szz".format(repo_key))
            continue

        szz_log[repo_key] = {}
        szz_log[repo_key]["finished"] = False
        szz_log[repo_key]["start_time"] = str(datetime.now())

        bug_matching_path = os.path.join(
            repo_def["output_dir"],
            "{}_bug_commit_matching.csv".format(repo_key)
        )

        output_path = os.path.join(
            repo_def["output_dir"],
            "{}_bug_inducing_file_changes.csv".format(repo_key)
        )

        bug_commit_df = pd.read_csv(bug_matching_path)

        find_bug_inducing_commits(
            repo, bug_commit_df, output_path)

        print("Finished {}".format(repo_key))

        szz_log[repo_key]["end_time"] = str(datetime.now())
        szz_log[repo_key]["finished"] = True

        with open(SZZ_LOG_PATH, "w") as f_stream:
            json.dump(szz_log, f_stream)


if __name__ == "__main__":
    main()
