""" Prepares input trees and saves them """

import os
import pickle
import zipfile
from datetime import date
import pandas as pd
from tqdm import tqdm

from vulnerability_prediction import REPOS
from vulnerability_prediction.utils import LOGGER

AST_DIR = REPOS["wireshark"]["ast_output_dir"]


def read_ast_dfs(summary_df, only_related=True):
    """Iterates over AST summaries and reads their dataframes"""

    trees = []

    if only_related:
        vuln_files = summary_df[summary_df.is_vuln == 1].file.unique()
        summary_df = summary_df[summary_df.file.isin(vuln_files)]

    for _, commit, file_name, func_name, out_file, is_vuln \
            in tqdm(summary_df.to_records()):

        try:
            path_splitted = out_file.split("\\")
            file_path = os.path.join(AST_DIR, *path_splitted[7:])

            df = pd.read_csv(file_path, compression="gzip")
            trees.append({
                "df": df,
                "file": file_name,
                "method": func_name,
                "commit": commit,
                "label": is_vuln
            })
        except Exception as e:
            print(e)
            pass

    return trees


def prune_tree(tree_df):
    node_types_to_remove = ["CursorKind.UNEXPOSED_EXPR"]

    kinds = tree_df.kind.values

    if not any([node_type in kinds for node_type in node_types_to_remove]):
        return tree_df

    ix_to_del = []
    for row in tree_df.itertuples():
        if row.kind in node_types_to_remove:
            ix_to_del.append(row.Index)
            children = tree_df[tree_df.parent_uuid == row.uuid]
            parent = tree_df[tree_df.uuid == row.parent_uuid].iloc[0]

            tree_df.at[children.index, "parent_uuid"] = parent.uuid
            tree_df.at[children.index,
                       "level"] = tree_df.loc[children.index, "level"] - 1

    return tree_df.drop(ix_to_del)


def prune_trees(trees):
    for tree in tqdm(trees):
        tree["df"] = prune_tree(tree["df"])

    return trees


def compare_trees(tree_1, tree_2):
    """ Compare trees for equality """
    if len(tree_1) != len(tree_2):
        return False

    if tree_1.tokens.values[0] == tree_2.tokens.values[0]:
        return True

    return False


def drop_duplicates(trees):
    """ Iterate over trees and drop duplicates """
    seen = []
    duplicates = []

    # any([compare_trees(tree["df"], tree_2["df"]) for tree_2 in seen])
    for tree in tqdm(trees):
        has_duplicate = False
        for tree_2 in seen:
            if (tree["file"] != tree_2["file"] or 
                    tree["method"] != tree_2["method"]):
                continue

            if compare_trees(tree["df"], tree_2["df"]):
                has_duplicate = True
                duplicates.append((tree, tree_2))
                LOGGER.info("Seen duplicate... dups: {} seen: {}".format(
                    len(duplicates), len(seen)))
                break

        if not has_duplicate:
            seen.append(tree)

    return seen, duplicates


def run():
    """Main process"""

    cols = ["commit_id", "file", "func_name", "out_file", "is_vuln"]
    summary_df = pd.read_csv(os.path.join(AST_DIR, "summary.gz"), index_col=0)
    summary_df.sort_values("commit_date", ascending=False, inplace=True)

    LOGGER.info("Start reading trees")
    trees = read_ast_dfs(summary_df[cols], False)

    LOGGER.info("Removing trees that have less than or equal to 2 nodes")
    trees = [t for t in trees if len(t["df"]) > 2]

    LOGGER.info("Dropping duplicates")
    trees, duplicates = drop_duplicates(trees)
    LOGGER.info("%s trees after dropping duplicates", len(trees))

    LOGGER.info("Pruning trees")
    trees = prune_trees(trees)

    zip_name = "trees_{}.zip".format(str(date.today()))
    with zipfile.ZipFile(os.path.join(AST_DIR, zip_name), "w",
                         zipfile.ZIP_DEFLATED) as zip_file:
        zip_file.writestr("trees.pkl", pickle.dumps(trees))

    with open(os.path.join(AST_DIR, "trees.pkl"), "wb") as f:
        pickle.dump(trees, f)

    LOGGER.info("Saved %s trees successfully", len(trees))


if __name__ == "__main__":
    run()
