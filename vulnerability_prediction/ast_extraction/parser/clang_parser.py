""" ClangParser Module """

import uuid
import os
from ast import literal_eval
import clang.cindex
from clang.cindex import CursorKind
import pandas as pd
from .utils import plot_tree
from .base import BaseParser, BaseNode
from .token_context import TokenContext
from vulnerability_prediction.utils import LOGGER

# Tell clang.cindex where libclang.dylib is
clang.cindex.Config.set_library_path(r"C:\\Program Files\\LLVM\\bin")
TOKEN_CONTEXT = TokenContext()


class ClangNode(BaseNode):
    """ClangNode class"""

    def __init__(self, node, level, base_path, parent=None):
        super(ClangNode, self).__init__(node, level, base_path, parent)

        self.uuid = uuid.uuid4()
        self.node = node
        self.level = level
        self.base_path = base_path
        self.parent = parent
        self.def_node = None
        self.matched_line = None
        self.vuln_fixing = None

        if node is not None:
            self.children = self.__build_children(node.get_children())
            self.displayname = node.displayname
            self.spelling = node.spelling
            self.kind = node.kind
            self.type = node.type.kind
            self.extent_start = (node.extent.start.line,
                                 node.extent.start.column)
            self.extent_end = (node.extent.end.line,
                               node.extent.end.column)
            self.file = node.extent.start.file.name
            self.is_definition = node.is_definition()
            self.result_type = node.result_type.kind
            self.tokens = self.__get_tokens(
                [t.spelling for t in node.get_tokens()])
        else:
            self.children = []

    def __eq__(self, other):
        if isinstance(other, ClangNode):
            return self.node == other.node

        return False

    def __hash__(self):
        return self.node.hash if self.node is not None else hash(self.uuid)

    def __build_children(self, children):
        """Constructs ClangNode objects for children nodes"""
        return [
            ClangNode(n, self.level + 1, self.base_path, self)
            for n in children if n.extent.start.file and
            n.extent.start.file.name.startswith(self.base_path)
        ]

    @classmethod
    def __get_tokens(cls, tokens):
        tokens = [t for t in tokens if not t.startswith("/*")
                  and not t.startswith("//")]

        return TOKEN_CONTEXT.get_token_ids(tokens)

    def get_by_node(self, node):
        """
        Get ClangNode by clang.cindex.Cursor node
        :param: node: clang.cindex.Cursor
        :returns: ClangNode
        """
        if self.node == node:
            return self

        return None

    @property
    def longname(self):
        """Longname of the node"""
        return "-".join((str(self.short_summary),
                         str(self.parent.short_summary)
                         if self.parent else ""))

    @property
    def short_summary(self):
        """Short summary of node"""
        return {
            "level": self.level,
            "displayname": self.displayname,
            "kind": self.kind,
            "type": self.type,
            "extent_start": self.extent_start,
            "extent_end": self.extent_end
        }

    @property
    def full_summary(self):
        """Full summary of node"""
        return {
            "uuid": self.uuid,
            **self.short_summary,
            "file": self.file,
            "is_definition": self.is_definition,
            "result_type": self.result_type,
            "has_definition": self.def_node is not None,
            "parent_uuid": self.parent.uuid if self.parent else None,
            "matched_line": self.matched_line,
            "tokens": self.tokens
        }

    @property
    def signature(self):
        """Signature of node"""
        return {
            "displayname": self.displayname,
            "kind": self.kind,
            "type": self.type,
            "tokens": self.tokens,
            "is_definition": self.is_definition
        }

    def print(self, indent=0):
        """Print node"""
        print("{} level: {} SPELLING: {} KIND: {}, TYPE: {} EXTENT: ({}, {})"
              .format(
                  "{}|-".format(indent * "-"), self.level, self.displayname,
                  self.kind, self.type, self.extent_start, self.extent_end)
              )


class ClangParser(BaseParser):
    """ClangParser Class"""

    def __init__(self):
        super(ClangParser, self).__init__()

    @classmethod
    def traverse(cls, node, base_folder, parent=None, level=1, node_list=None):
        """
        Traverses over the entire AST and extracts ClangNodes
        :param node: clang.cindex.Cursor or ClangNode
            node instance
        :param base_folder: string
            base folder of the project
        :param parent: ClangNode
            parent ClangNode. Default = None
        :param level: int
            the level of the node in the tree. Default = 1
        :param node_list: list[ClangNode]
            list of nodes that have been extracted. Default = []
        :returns: list[ClangNode]
            list of nodes
        """
        if node_list is None:
            node_list = []

        if not isinstance(node, ClangNode):
            node_info = ClangNode(node, level, base_folder, parent)
        else:
            node_info = node

        if all([node_info.node.kind == CursorKind.FUNCTION_DECL,
                not node_info.is_definition]):
            def_node = node_info.node.get_definition()
            node_info.def_node = def_node

        node_list.append(node_info)

        # Recurse for children of this node
        for child in node_info.children:
            cls.traverse(child, base_folder,
                         node_info, level + 1, node_list)

        return node_list

    @classmethod
    def print_node(cls, node, indent=0):
        """ Prints given node """
        return node.print(indent)

    @classmethod
    def print_tree(cls, nodes, indent=0):
        """ Prints entire tree """
        for node in nodes:
            cls.print_node(node, indent)
            cls.print_tree(node.children, indent + 1)

    @classmethod
    def get_edgelist(cls, nodes, edge_list=None):
        """
        Constructs list of edges in the tree
        :param: nodes: list[ClangNode]
            node list
        :param: edge_list: list[tuple(ClangNode, ClangNode)]
            list of edge pairs. Default = None
        :returns: list[tuple(ClangNode, ClangNode)]
            list of edge_pairs
        """
        if edge_list is None:
            edge_list = []

        for node in nodes:
            if node is None:
                continue
            for child in node.children:
                edge_list.append((node, child))

            cls.get_edgelist(node.children, edge_list)

        return edge_list

    @classmethod
    def get_nodelist(cls, nodes, parents=None):
        """
        Returns list of children nodes descendant of parent nodes
        :param: nodes: list[ClangNode]
            node list
        :param: parents: list[ClangNode]
            list of parent nodes. Default = None
        :returns: list[ClangNode]
            list of descendant nodes
        """

        if parents is None:
            parents = [n for n in nodes if n.parent is None]
        edges = cls.get_edgelist(parents, [])

        # make unique
        nodes_ = list(dict.fromkeys(
            sum([[n1, n2] for n1, n2 in edges], [])).keys())
        for parent_node in parents:
            if parent_node not in nodes_:
                nodes_.insert(0, parent_node)

        return nodes_, edges

    def visualize_tree(self, nodes, parents=None):
        """
        Returns list of children nodes descendant of parent nodes
        :param: nodes: list[ClangNode]
            node list
        :param: parents: list[ClangNode]
            list of parent nodes. Default = None
        :returns: list[ClangNode]
            list of descendant nodes
        """
        nodes_, edges = self.get_nodelist(nodes, parents)
        LOGGER.info("Visualizing %d edges", len(edges))

        return plot_tree(nodes_, edges)

    @classmethod
    def to_pandas(cls, nodes):
        """
        Creates a pd.DataFrame from list of nodes
        :param: nodes: list[ClangNode]
            node list
        :returns: pd.DataFrame
            DataFrame of AST
        """
        node_summaries = [n.full_summary for n in nodes]
        return pd.DataFrame(node_summaries)

    def export_tree(self, nodes, file_name):
        """
        Saves the tree to a file
        :param: nodes: list[ClangNode]
            node list
        :param: file_name: string
            the name of file
        """
        LOGGER.info("Exporting tree with %d nodes to %s",
                    len(nodes), file_name)
        df_path = file_name + ".csv"

        df = self.to_pandas(nodes)
        df.to_csv(df_path, index=False)

    @staticmethod
    def find_functions(nodes):
        """
        Returns function nodes
        :param: nodes: list[ClangNode]
            list of nodes
        :returns: list[ClangNode]
            list of function nodes
        """
        kinds = [CursorKind.FUNCTION_DECL, CursorKind.CXX_METHOD]
        return [n for n in nodes if n.node.kind in kinds
                and n.node.is_definition()]

    def find_parent_function(self, nodes, lines):
        """
        Finds parent functions of specified lines
        :param: nodes: list[ClangNode]
            list of nodes
        :param: lines: list[int]
            list of lines
        :returns: list[ClangNode]
            list of function nodes
        """
        nodes_ = []
        funcs = self.find_functions(nodes)

        for line in lines:
            # pylint: disable = chained-comparison
            match = [n for n in nodes if n.node.extent.start.line <=
                     line and line <= n.node.extent.end.line]
            # pylint: enable = chained-comparison
            for n in match:
                n.matched_line = (
                    n.matched_line + [line] if n.matched_line else [line])

            match = [n for n in match if n in funcs]
            for n in match:
                if n not in nodes_:
                    nodes_.append(n)

        return nodes_

    @staticmethod
    def find_node_by_other(nodes, other):
        """
        Find noes that match to a specified node
        :param: nodes: list[ClangNode]
            list of nodes
        :param: other: ClangNode
            Node to match
        :returns: list[ClangNode]
            list of function nodes
        """
        match = [n for n in nodes if n.node.spelling ==
                 other.node.spelling and n.node.kind == other.node.kind]

        for node in match:
            node.matched_line = other.matched_line

        if len(match) > 1:
            match_ = [n for n in match if n.node.is_definition()]
            if len(match_) > 0:
                match = match_

        return match[0] if len(match) > 0 else None

    @staticmethod
    def from_pandas(df):
        """
        Constructs tree from a pd.DataFrame
        :param: df: pd.DataFrame
            DataFrame of tree
        :returns: list[ClangNode]
            List of tree nodes
        """
        nodes = []
        for _, row in df.iterrows():
            parent = [n for n in nodes if n.uuid == row["parent_uuid"]]
            parent = parent[0] if len(parent) > 0 else None
            n = ClangNode(None, row["level"], None, parent)
            n.uuid = row["uuid"]
            n.displayname = row["displayname"]
            n.kind = row["kind"]
            n.type = row["type"]
            n.extent_start = row["extent_start"]
            n.extent_end = row["extent_end"]
            n.file = row["file"]
            n.is_definition = row["is_definition"]
            n.result_type = row["result_type"]
            n.matched_line = (row["matched_line"]
                              if not pd.isnull(row["matched_line"])
                              else None)
            n.tokens = literal_eval(row["tokens"])
            nodes.append(n)

        for node in nodes:
            children = [
                n for n in nodes if n.parent and n.parent.uuid == node.uuid]
            node.children = children

        return nodes

    @staticmethod
    def compare_trees(nodes_1, nodes_2):
        """
        Compare two trees for equality
        :param: df: pd.DataFrame
            DataFrame of tree
        :returns: list[ClangNode]
            List of tree nodes
        """
        if len(nodes_1) != len(nodes_2):
            return False

        for idx, node_1 in enumerate(nodes_1):
            if node_1.signature != nodes_2[idx].signature:
                return False

        return True

    def parse(self, base_folder, file):
        """
        Parses AST of a given file
        :param: base_folder: string
            Name of project's base folder
        :param: file: string
            Name of file
        :returns: list[ClangNode]
            List of tree nodes
        """
        try:
            index = clang.cindex.Index.create()
            file_path = os.path.join(base_folder, file)

            args = ["-I{}".format(base_folder)]

            LOGGER.info("Parsing %s", file)

            if file.endswith(".cc") or file.endswith(".cpp"):
                args.extend(["-x", 'c++', '--std=c++11'])

            translation_unit = index.parse(file_path, args=args)

            root = translation_unit.cursor
            nodes = self.traverse(root, base_folder, None, 1, [])

            LOGGER.info("Parsed %s: Total nodes: %d", file, len(nodes))
            return nodes
        except clang.cindex.TranslationUnitLoadError:
            LOGGER.error("Failed to parse %s", file)
