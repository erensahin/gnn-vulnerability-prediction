""" AST Parser utils """

from igraph import Graph
import plotly
import plotly.graph_objs as go


def make_annotations(pos, text, M, id_node_matching,
                     font_size=10, font_color='rgb(0,0,0)'):
    """make annotations on plot"""
    if len(text) != len(pos):
        raise ValueError('The lists pos and text must have the same len')
    annotations = []

    for i, pos_elem in enumerate(pos):
        n_ = id_node_matching[i]
        annotations.append(
            dict(
                text="\t".join([n_.displayname, str(
                    n_.kind).replace('CursorKind.', '')]),
                x=pos[pos_elem][0], y=2 * M - pos[pos_elem][1],
                xref='x1', yref='y1',
                font=dict(color=font_color, size=font_size),
                showarrow=False
            )
        )
    return annotations


def plot_tree(nodes, edges):
    """plot a given tree"""
    n_nodes = len(nodes)
    G = Graph(directed=True)

    node_names = []
    node_id_matching = {}
    id_node_matching = {}
    for i, n in enumerate(nodes):
        name = n.longname
        node_names.append(name)
        node_id_matching[n.uuid] = i
        id_node_matching[i] = n

    edge_ids = [(node_id_matching[n_1.uuid],
                 node_id_matching[n_2.uuid]) for (n_1, n_2) in edges]

    node_ids = list(node_id_matching.values())
    G.add_vertices(node_ids)

    for edge in edge_ids:
        try:
            G.add_edge(*edge)
        except Exception as ex:
            print(ex)

    lay = G.layout()
    position = {
        k: [lay[k][0], id_node_matching[k].level] for k in range(n_nodes)
    }

    Y = [id_node_matching[k].level for k in range(n_nodes)]
    M = max(Y)

    # pylint: disable = not-an-iterable
    edge_list = [e.tuple for e in G.es]  # list of edges
    # pylint: enable = not-an-iterable

    x_n = [position[k][0] for k in range(len(position))]
    y_n = [2 * M - position[k][1] for k in range(len(position))]
    x_e = []
    y_e = []
    for edge in edge_list:
        n_1, n_2 = edge
        x_e += [position[edge[0]][0], position[edge[1]][0], None]
        y_e += [2 * M - id_node_matching[n_1].level,
                2 * M - id_node_matching[n_2].level, None]
        # Ye += [2*M-position[edge[0]][1], 2*M-position[edge[1]][1], None]

    labels = node_names
    colors = ['#6175c1' if v.matched_line is None else "red"
              for k, v in id_node_matching.items()]

    fig = go.Figure()
    scatter1 = go.Scatter(x=x_e,
                          y=y_e,
                          mode='lines',
                          line=dict(color='rgb(210,210,210)', width=1),

                          )
    scatter2 = go.Scatter(x=x_n,
                          y=y_n,
                          mode='markers',
                          name='bla',
                          marker=dict(size=32,
                                      color=colors,  # '#DB4551',
                                      line=dict(
                                          color='rgb(50,50,50)', width=1)
                                      ),
                          text=labels,
                          hoverinfo='text',
                          opacity=0.8
                          )

    fig.add_trace(scatter1)
    fig.add_trace(scatter2)

    axis = dict(showline=False,  # hide axis line, grid, ticklabels and  title
                zeroline=False,
                showgrid=False,
                showticklabels=False,
                )

    fig.update_layout(title='AST',
                      annotations=make_annotations(
                          position, labels, M, id_node_matching),
                      font_size=12,
                      showlegend=False,
                      xaxis=axis,
                      yaxis=axis,
                      margin={"l": 40, "r": 40, "b": 85, "t": 100},
                      hovermode='closest',
                      plot_bgcolor='rgb(248,248,248)'
                      )

    return lambda x: plotly.offline.plot(fig, filename=x, auto_open=False)
